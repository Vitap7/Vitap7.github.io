<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>React 1</title>
    <link href="/2022/06/16/React-1/"/>
    <url>/2022/06/16/React-1/</url>
    
    <content type="html"><![CDATA[<h2 id="Reactåˆå­¦ç¬”è®°ğŸ˜ï¼‰"><a class="header-anchor" href="#Reactåˆå­¦ç¬”è®°ğŸ˜ï¼‰"></a>Reactåˆå­¦ç¬”è®°ğŸ˜ï¼‰</h2><p>åœ¨ React ä¸­:</p><ul><li>ç»„ä»¶å¯ä»¥ import å®ƒä»¬éœ€è¦çš„æ¨¡å—ï¼Œå¹¶ä¸”åœ¨æ–‡ä»¶åº•éƒ¨å°†è‡ªèº« exportï¼Œä»¥è®©å…¶å®ƒç»„ä»¶ä½¿ç”¨ã€‚</li><li>ç»„ä»¶æ˜¯ç”¨ <code>PascalCase</code> ä¹Ÿå°±æ˜¯å¸•æ–¯å¡å‘½åæ³•å‘½åçš„ã€‚</li><li>é€šè¿‡æŠŠå˜é‡æ”¾åœ¨å¤§æ‹¬å·ä¸­ï¼Œæ‚¨å¯ä»¥è¯»å– JSX çš„å˜é‡ï¼Œ å¦‚<code>&#123;so&#125;</code></li><li>ä¸€äº› JSX å±æ€§ä¸ HTML å±æ€§ä¸ç›¸åŒï¼Œè¿™æ ·å°±ä¸ä¼šä¸JavaScriptçš„ä¿ç•™å­—ç›¸å†²çªï¼Œæ¯”å¦‚è¯´ï¼Œåœ¨ HTML ä¸­çš„ <code>class</code> ä¼šåœ¨ JSX ä¸­è½¬è¯‘ä¸º <code>className</code>ã€‚ æ³¨æ„è¿™äº›å±æ€§éƒ½æ˜¯é©¼å³°å¼å‘½åçš„ã€‚</li><li>Props å°±åƒå±æ€§ä¸€æ ·å†™åœ¨ç»„ä»¶é‡Œï¼Œå¹¶ä¸”ä¼ å…¥ç»„ä»¶ã€‚</li></ul><h3 id="Handler"><a class="header-anchor" href="#Handler"></a>Handler</h3><p>In React, we write event handlers directly on the elements in our JSX, like this:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rea">&lt;button<br>  type=&quot;button&quot;<br>  onClick=&#123;() =&gt; alert(&quot;hi!&quot;)&#125;<br>&gt;<br>  Say hi!<br>&lt;/button&gt;<br></code></pre></td></tr></table></figure><p>In React applications, interactivity is rarely confined to just one component.</p><p>When we start giving ourselves the power to make new tasks, things that happen in the <code>&lt;Form /&gt;</code> component will affect the list rendered in <code>&lt;App /&gt;</code>.</p><h3 id="å­ä¼ çˆ¶"><a class="header-anchor" href="#å­ä¼ çˆ¶"></a>å­ä¼ çˆ¶</h3><p>We canâ€™t pass data from child to parent in the same way as we pass data from parent to child using standard props.</p><p>Instead, we can write <strong>a function</strong> in <code>&lt;App /&gt;</code> that will <strong>expect</strong> some data from our form as an input, then pass that function to <code>&lt;Form /&gt;</code> as a prop. This function-as-a-prop is called a <strong>callback prop</strong>. Once we have our callback prop, we can call it inside <code>&lt;Form /&gt;</code> to send the right data to <code>&lt;App /&gt;</code>.</p><h3 id="State-and-the-useState-hook"><a class="header-anchor" href="#State-and-the-useState-hook"></a>State and the useState hook</h3><p>State is another powerful tool for React because components not only <em>own</em> state, but can <em>update</em> it later.</p><p>React provides a variety of special functions that allow us to provide new capabilities to components, like state. These functions are called <strong>hooks</strong>, and the <code>useState</code> hook, as its name implies, is precisely the one we need in order to give our component some state.</p><figure class="highlight re"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs re">import React, &#123; useState &#125; from <span class="hljs-string">&quot;react&quot;</span>;<br></code></pre></td></tr></table></figure><p>This allows us to import the <code>useState()</code> function by itself, and utilize it anywhere in this file.</p><p><code>useState()</code> creates a piece of state for a component, and its <strong>only parameter</strong> determines the <em>initial value</em> of that state. It <strong>returns two things</strong>: the state, and a function that can be used to update the state later.</p><p>eg.</p><figure class="highlight re"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs re">const <span class="hljs-literal">[<span class="hljs-identifier">name</span>, <span class="hljs-identifier">setName</span>]</span> = use<span class="hljs-constructor">State(&#x27;Use <span class="hljs-params">hooks</span>!&#x27;)</span>;<br></code></pre></td></tr></table></figure><p>Whatâ€™s going on in this line of code?</p><ul><li>We are setting the initial <code>name</code> value as â€œUse hooks!â€.</li><li>We are defining a function whose job is to modify <code>name</code>, called <code>setName()</code>.</li><li><code>useState()</code> returns these two things, so we are using array destructuring to capture them both in separate variables.</li></ul><h5 id="Reading-user-input"><a class="header-anchor" href="#Reading-user-input"></a>Reading user input</h5><p>Before we can change the value of name, we need to capture a userâ€™s input as they type. For this, we can listen to the <em>onChange</em> event.</p><p>To read the contents of the input field as they change, you can access the inputâ€™s <code>value</code> property. We can do this inside <code>handleChange()</code> by reading <code>e.target.value</code>. <code>e.target</code> represents the element that fired the <code>change</code> event â€” thatâ€™s our input. So, <code>value</code> is the text inside it.</p><p>You might notice that, when you <strong>click on a checkbox</strong>, it checks and unchecks appropriately. As a feature of HTML, the browser knows how to remember which checkbox inputs are checked or unchecked without our help. This feature hides a problem, however: toggling a checkbox doesnâ€™t change the state in our React application. This means that the browser and our app are now out-of-sync. We have to write our own code to put the browser back in sync with our app.</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>aloha</title>
    <link href="/2022/06/13/aloha/"/>
    <url>/2022/06/13/aloha/</url>
    
    <content type="html"><![CDATA[<p>ç¬¬ä¸€ç¯‡ï¼</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
