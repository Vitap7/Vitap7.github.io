<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>React 1</title>
    <link href="/2022/06/16/React-1/"/>
    <url>/2022/06/16/React-1/</url>
    
    <content type="html"><![CDATA[<h2 id="React初学笔记😝）"><a class="header-anchor" href="#React初学笔记😝）"></a>React初学笔记😝）</h2><p>在 React 中:</p><ul><li>组件可以 import 它们需要的模块，并且在文件底部将自身 export，以让其它组件使用。</li><li>组件是用 <code>PascalCase</code> 也就是帕斯卡命名法命名的。</li><li>通过把变量放在大括号中，您可以读取 JSX 的变量， 如<code>&#123;so&#125;</code></li><li>一些 JSX 属性与 HTML 属性不相同，这样就不会与JavaScript的保留字相冲突，比如说，在 HTML 中的 <code>class</code> 会在 JSX 中转译为 <code>className</code>。 注意这些属性都是驼峰式命名的。</li><li>Props 就像属性一样写在组件里，并且传入组件。</li></ul><h3 id="Handler"><a class="header-anchor" href="#Handler"></a>Handler</h3><p>In React, we write event handlers directly on the elements in our JSX, like this:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rea">&lt;button<br>  type=&quot;button&quot;<br>  onClick=&#123;() =&gt; alert(&quot;hi!&quot;)&#125;<br>&gt;<br>  Say hi!<br>&lt;/button&gt;<br></code></pre></td></tr></table></figure><p>In React applications, interactivity is rarely confined to just one component.</p><p>When we start giving ourselves the power to make new tasks, things that happen in the <code>&lt;Form /&gt;</code> component will affect the list rendered in <code>&lt;App /&gt;</code>.</p><h3 id="子传父"><a class="header-anchor" href="#子传父"></a>子传父</h3><p>We can’t pass data from child to parent in the same way as we pass data from parent to child using standard props.</p><p>Instead, we can write <strong>a function</strong> in <code>&lt;App /&gt;</code> that will <strong>expect</strong> some data from our form as an input, then pass that function to <code>&lt;Form /&gt;</code> as a prop. This function-as-a-prop is called a <strong>callback prop</strong>. Once we have our callback prop, we can call it inside <code>&lt;Form /&gt;</code> to send the right data to <code>&lt;App /&gt;</code>.</p><h3 id="State-and-the-useState-hook"><a class="header-anchor" href="#State-and-the-useState-hook"></a>State and the useState hook</h3><p>State is another powerful tool for React because components not only <em>own</em> state, but can <em>update</em> it later.</p><p>React provides a variety of special functions that allow us to provide new capabilities to components, like state. These functions are called <strong>hooks</strong>, and the <code>useState</code> hook, as its name implies, is precisely the one we need in order to give our component some state.</p><figure class="highlight re"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs re">import React, &#123; useState &#125; from <span class="hljs-string">&quot;react&quot;</span>;<br></code></pre></td></tr></table></figure><p>This allows us to import the <code>useState()</code> function by itself, and utilize it anywhere in this file.</p><p><code>useState()</code> creates a piece of state for a component, and its <strong>only parameter</strong> determines the <em>initial value</em> of that state. It <strong>returns two things</strong>: the state, and a function that can be used to update the state later.</p><p>eg.</p><figure class="highlight re"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs re">const <span class="hljs-literal">[<span class="hljs-identifier">name</span>, <span class="hljs-identifier">setName</span>]</span> = use<span class="hljs-constructor">State(&#x27;Use <span class="hljs-params">hooks</span>!&#x27;)</span>;<br></code></pre></td></tr></table></figure><p>What’s going on in this line of code?</p><ul><li>We are setting the initial <code>name</code> value as “Use hooks!”.</li><li>We are defining a function whose job is to modify <code>name</code>, called <code>setName()</code>.</li><li><code>useState()</code> returns these two things, so we are using array destructuring to capture them both in separate variables.</li></ul><h5 id="Reading-user-input"><a class="header-anchor" href="#Reading-user-input"></a>Reading user input</h5><p>Before we can change the value of name, we need to capture a user’s input as they type. For this, we can listen to the <em>onChange</em> event.</p><p>To read the contents of the input field as they change, you can access the input’s <code>value</code> property. We can do this inside <code>handleChange()</code> by reading <code>e.target.value</code>. <code>e.target</code> represents the element that fired the <code>change</code> event — that’s our input. So, <code>value</code> is the text inside it.</p><p>You might notice that, when you <strong>click on a checkbox</strong>, it checks and unchecks appropriately. As a feature of HTML, the browser knows how to remember which checkbox inputs are checked or unchecked without our help. This feature hides a problem, however: toggling a checkbox doesn’t change the state in our React application. This means that the browser and our app are now out-of-sync. We have to write our own code to put the browser back in sync with our app.</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>aloha</title>
    <link href="/2022/06/13/aloha/"/>
    <url>/2022/06/13/aloha/</url>
    
    <content type="html"><![CDATA[<p>第一篇！</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
