<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>LC 155.最小栈</title>
    <link href="/2022/06/20/LC-155-%E6%9C%80%E5%B0%8F%E6%A0%88/"/>
    <url>/2022/06/20/LC-155-%E6%9C%80%E5%B0%8F%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a class="header-anchor" href="#题目描述"></a>题目描述</h3><blockquote><p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p><p>实现 MinStack 类:</p><p>MinStack() 初始化堆栈对象。<br>void push(int val) 将元素val推入堆栈。<br>void pop() 删除堆栈顶部的元素。<br>int top() 获取堆栈顶部的元素。<br>int getMin() 获取堆栈中的最小元素。</p></blockquote><p><em>来源：力扣（LeetCode）</em><br><em>链接：<a href="https://leetcode.cn/problems/min-stack">https://leetcode.cn/problems/min-stack</a></em><br><em>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</em></p><h3 id="题解"><a class="header-anchor" href="#题解"></a>题解</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> <span class="hljs-title class_">MinStack</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">minEle</span> = <span class="hljs-title class_">Infinity</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">stackMin</span> = [];<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">stackA</span> = [];<br>&#125;;<br><br><span class="hljs-comment">/** </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">x</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">void</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title class_">MinStack</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">push</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) &#123;<br>    <span class="hljs-keyword">if</span>(x&lt;=<span class="hljs-variable language_">this</span>.<span class="hljs-property">minEle</span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">minEle</span> = x;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">stackMin</span>.<span class="hljs-title function_">push</span>(x);<br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">stackA</span>.<span class="hljs-title function_">push</span>(x);<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">void</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title class_">MinStack</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">pop</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> a = <span class="hljs-variable language_">this</span>.<span class="hljs-property">stackA</span>.<span class="hljs-title function_">pop</span>();<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">stackA</span>.<span class="hljs-title function_">push</span>(a);<br>    <span class="hljs-keyword">if</span>(a === <span class="hljs-variable language_">this</span>.<span class="hljs-property">minEle</span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">stackMin</span>.<span class="hljs-title function_">pop</span>();<br>        <span class="hljs-keyword">let</span> newMin = <span class="hljs-variable language_">this</span>.<span class="hljs-property">stackMin</span>.<span class="hljs-title function_">pop</span>();<br>        <span class="hljs-keyword">if</span>(newMin !== <span class="hljs-literal">undefined</span>)&#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">minEle</span> = newMin;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">stackMin</span>.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">minEle</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">minEle</span> = <span class="hljs-title class_">Infinity</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">stackA</span>.<span class="hljs-title function_">pop</span>();<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title class_">MinStack</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">top</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> top = <span class="hljs-variable language_">this</span>.<span class="hljs-property">stackA</span>.<span class="hljs-title function_">pop</span>();<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">stackA</span>.<span class="hljs-title function_">push</span>(top);<br>    <span class="hljs-keyword">return</span> top;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title class_">MinStack</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getMin</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">minEle</span>;<br>&#125;;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MinStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * var obj = new MinStack()</span><br><span class="hljs-comment"> * obj.push(val)</span><br><span class="hljs-comment"> * obj.pop()</span><br><span class="hljs-comment"> * var param_3 = obj.top()</span><br><span class="hljs-comment"> * var param_4 = obj.getMin()</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>MinStack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>事件循环</title>
    <link href="/2022/06/16/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
    <url>/2022/06/16/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="栈-堆-队列"><a class="header-anchor" href="#栈-堆-队列"></a>栈 堆 队列</h2><p><img src="https://mdn.mozillademos.org/files/17124/The_Javascript_Runtime_Environment_Example.svg" alt="Stack, heap, queue"></p><p>栈：函数调用</p><p>堆：对象分配</p><p>队列：消息处理</p><p>函数的处理会一直进行到执行栈再次为空为止；然后事件循环将会处理队列中的下一个消息（如果还有的话）。</p><h2 id="事件循环"><a class="header-anchor" href="#事件循环"></a>事件循环</h2><p>函数 <code>setTimeout</code> 接受两个参数：待加入队列的消息和一个时间值（可选，默认为 0）。这个时间值代表了消息被实际加入到队列的<strong>最小</strong>延迟时间。如果队列中没有其它消息并且栈为空，在这段延迟时间过去之后，消息会被马上处理。但是，如果有其它消息，<code>setTimeout</code> 消息必须等待其它消息处理完。因此第二个参数仅仅表示最少延迟时间，而非确切的等待时间。</p><p>下面的例子演示了这个概念（<code>setTimeout</code> 并不会在计时器到期之后直接执行）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getSeconds</span>();<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 输出 &quot;2&quot;，表示回调函数并没有在 500 毫秒之后立即执行</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Ran after &quot;</span> + (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getSeconds</span>() - s) + <span class="hljs-string">&quot; seconds&quot;</span>);<br>&#125;, <span class="hljs-number">500</span>);<br><br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getSeconds</span>() - s &gt;= <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Good, looped for 2 seconds&quot;</span>);<br>    <span class="hljs-keyword">break</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>基本上，<code>setTimeout</code> 需要等待当前队列中所有的消息都处理完毕之后才能执行，即使已经超出了由第二参数所指定的时间。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;这是开始&#x27;</span>);<br><br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">cb</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;这是来自第一个回调的消息&#x27;</span>);<br>  &#125;);<br><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;这是一条消息&#x27;</span>);<br><br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">cb1</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;这是来自第二个回调的消息&#x27;</span>);<br>  &#125;, <span class="hljs-number">0</span>);<br><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;这是结束&#x27;</span>);<br><br>&#125;)();<br><br><span class="hljs-comment">// &quot;这是开始&quot;</span><br><span class="hljs-comment">// &quot;这是一条消息&quot;</span><br><span class="hljs-comment">// &quot;这是结束&quot;</span><br><span class="hljs-comment">// &quot;这是来自第一个回调的消息&quot;</span><br><span class="hljs-comment">// &quot;这是来自第二个回调的消息&quot;</span><br></code></pre></td></tr></table></figure><p>JavaScript的事件循环模型与许多其他语言不同的一个非常有趣的特性是，它永不阻塞。</p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Promise</title>
    <link href="/2022/06/16/Promise/"/>
    <url>/2022/06/16/Promise/</url>
    
    <content type="html"><![CDATA[<h3 id="一个Promise链"><a class="header-anchor" href="#一个Promise链"></a>一个Promise链</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">doSomething</span>().<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">doSomethingElse</span>(result);<br>&#125;)<br>.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">newResult</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">doThirdThing</span>(newResult);<br>&#125;)<br>.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">finalResult</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Got the final result: &#x27;</span> + finalResult);<br>&#125;)<br>.<span class="hljs-title function_">catch</span>(failureCallback);<br></code></pre></td></tr></table></figure><p>then 里的参数是可选的，<code>catch(failureCallback)</code> 是 <code>then(null, failureCallback)</code> 的缩略形式。</p><p><strong>注意：</strong> 一定要有返回值，否则，callback 将无法获取上一个 Promise 的结果。</p><h3 id="Catch-的后续链式操作"><a class="header-anchor" href="#Catch-的后续链式操作"></a>Catch 的后续链式操作</h3><p>有可能会在一个回调失败之后继续使用链式操作，即，使用一个 <code>catch</code>，这对于在链式操作中抛出一个失败之后，再次进行新的操作会很有用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;初始化&#x27;</span>);<br><br>    <span class="hljs-title function_">resolve</span>();<br>&#125;)<br>.<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;有哪里不对了&#x27;</span>);<br><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;执行「这个」”&#x27;</span>);<br>&#125;)<br>.<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;执行「那个」&#x27;</span>);<br>&#125;)<br>.<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;执行「这个」，无论前面发生了什么&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>output:</p> <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">初始化<br>执行“那个”<br>执行“这个”，无论前面发生了什么<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Promise</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React 1</title>
    <link href="/2022/06/16/React-1/"/>
    <url>/2022/06/16/React-1/</url>
    
    <content type="html"><![CDATA[<h2 id="React初学笔记😝）"><a class="header-anchor" href="#React初学笔记😝）"></a>React初学笔记😝）</h2><p>在 React 中:</p><ul><li>组件可以 import 它们需要的模块，并且在文件底部将自身 export，以让其它组件使用。</li><li>组件是用 <code>PascalCase</code> 也就是帕斯卡命名法命名的。</li><li>通过把变量放在大括号中，您可以读取 JSX 的变量， 如<code>&#123;so&#125;</code></li><li>一些 JSX 属性与 HTML 属性不相同，这样就不会与JavaScript的保留字相冲突，比如说，在 HTML 中的 <code>class</code> 会在 JSX 中转译为 <code>className</code>。 注意这些属性都是驼峰式命名的。</li><li>Props 就像属性一样写在组件里，并且传入组件。</li></ul><h3 id="Handler"><a class="header-anchor" href="#Handler"></a>Handler</h3><p>In React, we write event handlers directly on the elements in our JSX, like this:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rea">&lt;button<br>  type=&quot;button&quot;<br>  onClick=&#123;() =&gt; alert(&quot;hi!&quot;)&#125;<br>&gt;<br>  Say hi!<br>&lt;/button&gt;<br></code></pre></td></tr></table></figure><p>In React applications, interactivity is rarely confined to just one component.</p><p>When we start giving ourselves the power to make new tasks, things that happen in the <code>&lt;Form /&gt;</code> component will affect the list rendered in <code>&lt;App /&gt;</code>.</p><h3 id="子传父"><a class="header-anchor" href="#子传父"></a>子传父</h3><p>We can’t pass data from child to parent in the same way as we pass data from parent to child using standard props.</p><p>Instead, we can write <strong>a function</strong> in <code>&lt;App /&gt;</code> that will <strong>expect</strong> some data from our form as an input, then pass that function to <code>&lt;Form /&gt;</code> as a prop. This function-as-a-prop is called a <strong>callback prop</strong>. Once we have our callback prop, we can call it inside <code>&lt;Form /&gt;</code> to send the right data to <code>&lt;App /&gt;</code>.</p><h3 id="State-and-the-useState-hook"><a class="header-anchor" href="#State-and-the-useState-hook"></a>State and the useState hook</h3><p>State is another powerful tool for React because components not only <em>own</em> state, but can <em>update</em> it later.</p><p>React provides a variety of special functions that allow us to provide new capabilities to components, like state. These functions are called <strong>hooks</strong>, and the <code>useState</code> hook, as its name implies, is precisely the one we need in order to give our component some state.</p><figure class="highlight re"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs re">import React, &#123; useState &#125; from <span class="hljs-string">&quot;react&quot;</span>;<br></code></pre></td></tr></table></figure><p>This allows us to import the <code>useState()</code> function by itself, and utilize it anywhere in this file.</p><p><code>useState()</code> creates a piece of state for a component, and its <strong>only parameter</strong> determines the <em>initial value</em> of that state. It <strong>returns two things</strong>: the state, and a function that can be used to update the state later.</p><p>eg.</p><figure class="highlight re"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs re">const <span class="hljs-literal">[<span class="hljs-identifier">name</span>, <span class="hljs-identifier">setName</span>]</span> = use<span class="hljs-constructor">State(&#x27;Use <span class="hljs-params">hooks</span>!&#x27;)</span>;<br></code></pre></td></tr></table></figure><p>What’s going on in this line of code?</p><ul><li>We are setting the initial <code>name</code> value as “Use hooks!”.</li><li>We are defining a function whose job is to modify <code>name</code>, called <code>setName()</code>.</li><li><code>useState()</code> returns these two things, so we are using array destructuring to capture them both in separate variables.</li></ul><h5 id="Reading-user-input"><a class="header-anchor" href="#Reading-user-input"></a>Reading user input</h5><p>Before we can change the value of name, we need to capture a user’s input as they type. For this, we can listen to the <em>onChange</em> event.</p><p>To read the contents of the input field as they change, you can access the input’s <code>value</code> property. We can do this inside <code>handleChange()</code> by reading <code>e.target.value</code>. <code>e.target</code> represents the element that fired the <code>change</code> event — that’s our input. So, <code>value</code> is the text inside it.</p><p>You might notice that, when you <strong>click on a checkbox</strong>, it checks and unchecks appropriately. As a feature of HTML, the browser knows how to remember which checkbox inputs are checked or unchecked without our help. This feature hides a problem, however: toggling a checkbox doesn’t change the state in our React application. This means that the browser and our app are now out-of-sync. We have to write our own code to put the browser back in sync with our app.</p>]]></content>
    
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>aloha</title>
    <link href="/2022/06/13/aloha/"/>
    <url>/2022/06/13/aloha/</url>
    
    <content type="html"><![CDATA[<p>第一篇！范玉琳是🐷</p>]]></content>
    
    
    
    <tags>
      
      <tag>fylsz</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
